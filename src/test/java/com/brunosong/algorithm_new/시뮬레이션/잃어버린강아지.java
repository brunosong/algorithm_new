package com.brunosong.algorithm_new.시뮬레이션;

import org.assertj.core.api.Assertions;
import org.junit.jupiter.api.Test;

public class 잃어버린강아지 {

    @Test
    void test() {

        //잃어버린 강아지
        //현수는 농사지을 땅을 찾아 강아지를 데리고 산으로 들로 땅을 찾아 다니고 있었다. 숲속에서
        //낮잠을 자던 현수는 강아지가 도망가버려 강아지를 잃게 되었다. 강아지가 어디로 갔는지 모
        //르는 현수는 강아지를 찾아 나섰다. 다행히 강아지에게 위치 추적기가 달려 있어 핸드폰 실시
        //간 위성지도로 현수의 위치와 강아지의 위치, 그리고 근처의 지도를 현수는 알 수 있습니다.
        //지도의 크기는 항상 10*10이며, 각각의 칸에는 각각 나무, 빈칸, 강아지, 그리고 현수가 있을
        //수 있습니다. 지도는 다음과 같이 주어진다.
        //0 - 빈칸, 1 - 나무, 2 - 현수, 3 - 강아지
        //강아지와 현수는 항상 고정된 방법으로 지도를 다닌다. 먼저 북쪽(지도에서 위쪽)으로 출발하
        //되, 계속 한쪽방향으로 가다가 나무나 지도의 끝에 이르면 90도 시계방향으로 회전하게 된다.
        //한 칸을 이동하거나, 방향을 회전할 때에는 1분이 소요된다.
        //만약 이동, 또는 회전을 한 후 현수와 강아지가 같은 칸에 있게 되면 현수가 강아지를 찾게 된
        //다. 현수와 강아지가 있는 숲의 지도정보가 board에 주어지면 몇 분 후에 현수가 강아지를 찾
        //을 수 있는지 구하는 프로그램을 작성하세요. 10,000분 후에도 찾을 수 없으면 0을 반환합니
        //다.

        int[][] arr1 = {{0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
                {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
                {0, 0, 0, 1, 0, 0, 0, 1, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 1, 0, 0, 0, 2, 0, 0},
                {1, 0, 0, 0, 0, 0, 1, 0, 0, 0},
                {0, 0, 0, 1, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 3, 0, 0, 0, 1},
                {0, 0, 0, 1, 0, 1, 0, 0, 0, 0},
                {0, 1, 0, 1, 0, 0, 0, 0, 0, 0}};
        Assertions.assertThat(solution(arr1)).isEqualTo(51);

        int[][] arr2 = {{1, 0, 0, 0, 1, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
                {0, 0, 1, 1, 0, 0, 0, 1, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 1, 0, 1, 0, 0, 0, 0},
                {1, 0, 0, 0, 0, 0, 1, 0, 1, 0},
                {0, 0, 0, 1, 0, 0, 0, 0, 0, 0},
                {0, 0, 1, 0, 0, 0, 0, 0, 2, 1},
                {0, 0, 0, 1, 0, 1, 0, 0, 0, 1},
                {0, 1, 0, 1, 0, 0, 0, 0, 0, 3}};

        Assertions.assertThat(solution(arr2)).isEqualTo(17);



    }


    public int solution(int[][] board){
        int answer = 0;

        // 총 사이즈
        int n = board.length;

        // 경로이동 좌표 위, 오른쪽, 아래, 왼쪽
        int[] dx = {-1,0,1,0};
        int[] dy = { 0,1,0,-1};

        int x1 = 0, y1 = 0; //현수
        int x2 = 0, y2 = 0; //강아지

        //현수와 강아지 위치 찾기
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                if(board[i][j] == 2) {
                    x1 = i;
                    y1 = j;
                }
                if(board[i][j] == 3) {
                    x2 = i;
                    y2 = j;
                }
            }
        }

        //나아갈 방향 셋팅 0 = 북쪽, 1 = 동, 2 = 남, 3 = 서
        int d1 = 0, d2 = 0;

        // 총 돌아다녀야 하는 카운트
        int count = 0;
        while (count < 10000) {
            count++;
            //현수 방향
            int nx1 = x1 + dx[d1];
            int ny1 = y1 + dy[d1];

            //강아지 방향
            int nx2 = x2 + dx[d2];
            int ny2 = y2 + dy[d2];

            boolean flag1 = true;
            boolean flag2 = true;

            // 벽과 나무 검사에서 걸리게 되면
            if(nx1 < 0 || nx1 >= n || ny1 < 0 || ny1 >= n || board[nx1][ny1] == 1) {
                //방향 전환
                d1 = (d1 + 1) % 4;
                flag1 = false;
            }

            if(nx2 < 0 || nx2 >= n || ny2 < 0 || ny2 >= n || board[nx2][ny2] == 1) {
                //방향 전환
                d2 = (d2 + 1) % 4;
                flag2 = false;
            }

            if(flag1) {
                x1 = nx1;
                y1 = ny1;
            }

            if(flag2) {
                x2 = nx2;
                y2 = ny2;
            }

            if(x1 == x2 && y1 == y2) break;

        }

        if(count >= 10000) return 0;
        return count;

    }




}
